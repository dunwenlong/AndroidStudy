<!DOCTYPE html>
<html>
<body style="padding-left: 1cm;">
    <h1 style="text-align: center;">java锁相关知识</h1>
    <h2>1、读写锁</h2>
    <p>
        ReadWriteLock 同lock一样也是一个接口，提供了ReadLock 和 WriteLock两种锁的操作机制，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。一个获得了读锁的线程必须能够看到前一个释放的写锁更新的内容。
        理论上，读写锁比互斥锁允许对于共享数据更大程度的并发。与互斥锁相比，读写锁是否能够提高性能取决于读写数据的频率、读取和写入操作的持续时间、以及读线程和写线程之间的竞争。
    </p>
    <h3>使用场景</h3>
    <p>
        假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。例如，最初填充有数据，然后很少修改的集合，同时频繁搜索（例如某种目录）是使用读写锁的理想候选项。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写。这就需要一个读/写锁来解决这个问题。
    </p>
    <h3>互斥原则</h3>
    <p>
        读读能共存，读写不能共存，写写不能共存
    </p>
    <h3>公平锁</h3>
    <p>
        在锁上等待时间最长的线程将获得锁的使用权
    </p>


    <h2> 2、死锁 </h2>
    <h3>死锁</h3>
    <p>
        多个线程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。
    </p>


    <h2> 3、可重入锁 </h2>
    <p>
        synchronized和ReenTrantLock
        什么是 “可重入”，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。<br></br>
        ReenTrantLock独有的能力：
        1 . ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。

        2. ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

        3. ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。
    </p>
    <h3> 区别 </h3>
    <p>
        这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成
        便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。      
    </p>


    <h2> 4、轻量级自旋锁 </h2>

    
    <h2> 5、Volatile关键字 </h2>
</body>
</html>